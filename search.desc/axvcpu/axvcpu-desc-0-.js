searchState.loadedDescShard("axvcpu", 0, "AxVCpu - Virtual CPU abstraction for ArceOS hypervisors.\nTrait representing the per-CPU architecture-specific …\nArchitecture-specific virtual CPU trait definition.\nHost per-CPU states to run the guest.\nArchitecture-independent virtual CPU implementation.\nReasons for VM-Exits returned by AxArchVCpu::run.\nHardware abstraction layer interfaces for VCpu operations.\nMutable runtime state of a virtual CPU.\nVCpu execution is blocked (waiting for I/O, etc.)\nThe guest VCpu has been powered down.\nRequest to bring up a secondary CPU core.\nArchitecture-specific configuration for VCpu creation.\nInitial state after VCpu creation, not yet initialized\nAn external interrupt was delivered to the VCpu.\nVM entry failed due to invalid VCpu state or configuration.\nVCpu is initialized and ready to be bound to a physical CPU\nThe guest VCpu has executed a halt instruction and is now …\nA guest instruction triggered a hypercall to the …\nInvalid state - indicates an error occurred during state …\nThe guest performed a port-based I/O read operation.\nThe guest performed a port-based I/O write operation.\nMemory management interfaces required by the VCpu …\nThe guest performed a Memory-Mapped I/O (MMIO) read …\nThe guest performed a Memory-Mapped I/O (MMIO) write …\nA nested page fault occurred during guest memory access.\nNo special handling required - the VCpu handled the exit …\nVCpu is bound to a physical CPU and ready for execution\nVCpu is currently executing on a physical CPU\nThe guest is attempting to send an Inter-Processor …\nArchitecture-specific configuration for VCpu setup.\nThe guest performed a system register read operation.\nThe guest performed a system register write operation.\nThe guest has requested system-wide shutdown.\nRepresents the current execution state of a virtual CPU.\nReturn the architecture-specific per-CPU state. Panics if …\nReturn the mutable architecture-specific per-CPU state. …\nBinds the VCpu to the current physical CPU for execution.\nBind the VCpu to the current physical CPU.\nClear the current vcpu on the current physical CPU.\nReturns the preferred physical CPU for this VCpu.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the architecture-specific VCpu.\nGet the current VCpu on the current physical CPU.\nGet a mutable reference to the current VCpu on the current …\nDisable hardware virtualization on the current CPU.\nDisable hardware virtualization on the current CPU.\nEnable hardware virtualization on the current CPU.\nEnable hardware virtualization on the current CPU.\nReturns the unique identifier of this VCpu.\nInitialize the per-CPU state.\nInject an interrupt to the VCpu.\nInject an interrupt to the VCpu.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFetches the current interrupt (IRQ) number from the …\nFetches the current interrupt (IRQ) number from the …\nDispatches an interrupt request (IRQ) to the underlying …\nDispatches an interrupt request (IRQ) to the underlying …\nChecks if this VCpu is the Bootstrap Processor (BSP).\nWhether hardware virtualization is enabled on the current …\nWhether the current CPU has hardware virtualization …\nExecute an operation on the architecture-specific VCpu, …\nCreates a new architecture-specific VCpu instance.\nCreate a new per-CPU state.\nCreates a new virtual CPU instance.\nCreate a new, uninitialized per-CPU state.\nReturns the set of physical CPUs that can run this VCpu.\nExecutes the VCpu until a VM exit occurs.\nRun the VCpu.\nSet the current VCpu on the current physical CPU.\nSets the guest entry point where VCpu execution will begin.\nSets the entry address of the VCpu.\nSets the Extended Page Table (EPT) root for memory …\nSets the value of a general-purpose register.\nSets the value of a general-purpose register according to …\nSets the return value that will be delivered to the guest.\nSets the return value of the VCpu.\nSet the state of the VCpu.\nCompletes VCpu initialization and prepares it for …\nSets up the VCpu for execution.\nGets the current execution state of the VCpu.\nTransition the state of the VCpu. If the current state is …\nUnbinds the VCpu from the current physical CPU.\nUnbind the VCpu from the current physical CPU.\nGet the id of the VM this vcpu belongs to.\nExecute a block with the current VCpu set to <code>&amp;self</code>.\nExecute a block with the state of the VCpu transitioned …\nPower state information (currently unused)\nType of access that was attempted (read/write/execute)\nGuest physical address being read from\nGuest physical address being written to\nAddress/identifier of the system register being read\nAddress/identifier of the system register being written\nGuest physical address that caused the fault\nArgument to pass to the secondary CPU\nArguments passed to the hypercall (up to 6 parameters)\nData being written to the memory location\nData being written to the I/O port\nGuest physical address where the secondary CPU should …\nHardware-specific failure reason code\nThe hypercall number identifying the requested service\nI/O port number being read from\nI/O port number being written to\nIndex of the guest register that will receive the read …\nIndex of the guest register that will receive the read …\nWidth of the destination register\nWhether to broadcast the IPI to all CPUs except the sender\nWhether to send the IPI to the current CPU (self-IPI)\nWhether to sign-extend the read value to fill the register\nTarget CPU identifier to be started\nTarget CPU identifier to receive the IPI\nAuxiliary field for complex target CPU specifications\nData being written to the system register\nHardware interrupt vector number\nIPI vector/interrupt number to deliver\nWidth/size of the memory access (8, 16, 32, or 64 bits)\nWidth/size of the memory access (8, 16, 32, or 64 bits)\nWidth of the I/O access (8, 16, or 32 bits)\nWidth of the I/O access (8, 16, or 32 bits)")